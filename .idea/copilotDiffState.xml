<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/graph/graph.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/graph/graph.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;title&gt;Poker Winnings Graph&lt;/title&gt;&#10;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;&gt;&lt;/script&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;canvas id=&quot;winningsChart&quot; style=&quot;width:100%; display:block;&quot;&gt;&lt;/canvas&gt;&#10;&lt;script&gt;&#10;&#10;    const url = `https://docs.google.com/spreadsheets/d/e/2PACX-1vTAYSlBiWTAJ_th0XEzDk9fthNQBrF88_FdBry3l8l9IrcGuopvFoBzIY4Byb5yfTE0U-LyqGkmZxkX/pub?gid=0&amp;single=true&amp;output=csv`;&#10;&#10;    fetch(url)&#10;        .then(response =&gt; response.text()) // Use text() for CSV&#10;        .then(csv =&gt; {&#10;            // Simple CSV parsing (assumes no commas in values)&#10;            const lines = csv.trim().split('\n');&#10;            const headers = lines[0].split(',');&#10;            // Start from line 2 if you have a second header row, else use line 1&#10;            const dataRows = lines.slice(2).map(line =&gt; line.split(','));&#10;            // Filter out rows where the date (second column) is empty&#10;            const rows = dataRows.filter(row =&gt; row[1] &amp;&amp; row[1].trim() !== '');&#10;            // Filter out columns with empty header&#10;            const validColumns = headers.map((h, i) =&gt; ({h, i})).filter(x =&gt; x.h &amp;&amp; x.h.trim() !== '');&#10;            const filteredHeaders = validColumns.map(x =&gt; x.h);&#10;            // Convert all values to numbers (except empty strings)&#10;            const winnings = rows.map(row =&gt; validColumns.map(x =&gt; row[x.i] === '' ? 0 : Number(row[x.i])));&#10;            // Keep original cell values for presence detection (filtered)&#10;            const originalCells = rows.map(row =&gt; validColumns.map(x =&gt; row[x.i]));&#10;            // Compute cumulative sums for each player (column)&#10;            const cumulative = filteredHeaders.map((_, colIdx) =&gt; {&#10;                let sum = 0;&#10;                return winnings.map(row =&gt; sum += (row[colIdx] || 0));&#10;            });&#10;            // After cumulative is built, set values after last session (non-empty, nonzero) for each player to null&#10;            cumulative.forEach((arr, colIdx) =&gt; {&#10;                // Find last index where the original cell is not empty and not zero&#10;                let lastIdx = -1;&#10;                for (let i = arr.length - 1; i &gt;= 0; i--) {&#10;                    const cell = originalCells[i][colIdx];&#10;                    if (cell !== undefined &amp;&amp; cell !== '' &amp;&amp; cell !== '0' &amp;&amp; Number(cell) !== 0) {&#10;                        lastIdx = i;&#10;                        break;&#10;                    }&#10;                }&#10;                if (lastIdx &gt;= 0 &amp;&amp; lastIdx &lt; arr.length - 1) {&#10;                    for (let i = lastIdx + 1; i &lt; arr.length; i++) {&#10;                        arr[i] = null;&#10;                    }&#10;                }&#10;                // Do NOT set points with zero/missing delta to null here, so lines remain continuous&#10;            });&#10;            // Helper to determine if a point should be opaque or alpha&#10;            function isOpaquePoint(data, i) {&#10;                const prev = i &gt; 0 ? data[i] !== data[i-1] : false;&#10;                const next = i &lt; data.length-1 ? data[i] !== data[i+1] : false;&#10;                return prev || next;&#10;            }&#10;            const niceColors = [&#10;                &quot;#E15759&quot;, &quot;#4E79A7&quot;, &quot;#F28E2B&quot;, &quot;#76B7B2&quot;, &quot;#59A14F&quot;, &quot;#EDC948&quot;,&#10;                &quot;#B07AA1&quot;, &quot;#FF9DA7&quot;, &quot;#9C755F&quot;, &quot;#BAB0AC&quot;, &quot;#1F77B4&quot;, &quot;#AEC7E8&quot;,&#10;                &quot;#FF7F0E&quot;, &quot;#FFBB78&quot;, &quot;#2CA02C&quot;, &quot;#98DF8A&quot;, &quot;#D62728&quot;, &quot;#FF9896&quot;,&#10;                &quot;#9467BD&quot;, &quot;#C5B0D5&quot;, &quot;#8C564B&quot;, &quot;#C49C94&quot;, &quot;#E377C2&quot;, &quot;#F7B6D2&quot;,&#10;                &quot;#7F7F7F&quot;, &quot;#C7C7C7&quot;, &quot;#BCBD22&quot;, &quot;#DBDB8D&quot;, &quot;#17BECF&quot;, &quot;#9EDAE5&quot;,&#10;                &quot;#393b79&quot;, &quot;#5254a3&quot;, &quot;#6b6ecf&quot;, &quot;#9c9ede&quot;, &quot;#637939&quot;, &quot;#8ca252&quot;,&#10;                &quot;#b5cf6b&quot;, &quot;#cedb9c&quot;, &quot;#8c6d31&quot;, &quot;#bd9e39&quot;, &quot;#e7ba52&quot;, &quot;#e7cb94&quot;,&#10;                &quot;#843c39&quot;, &quot;#ad494a&quot;, &quot;#d6616b&quot;, &quot;#e7969c&quot;, &quot;#7b4173&quot;, &quot;#a55194&quot;,&#10;                &quot;#ce6dbd&quot;, &quot;#de9ed6&quot;, &quot;#1b9e77&quot;, &quot;#d95f02&quot;&#10;            ];&#10;            // Helper to convert hex to rgba with alpha&#10;            function hexToRgba(hex, alpha) {&#10;                // Accepts #RRGGBB or #RGB&#10;                if (hex.length === 7) {&#10;                    const r = parseInt(hex.slice(1, 3), 16);&#10;                    const g = parseInt(hex.slice(3, 5), 16);&#10;                    const b = parseInt(hex.slice(5, 7), 16);&#10;                    return `rgba(${r},${g},${b},${alpha})`;&#10;                } else if (hex.length === 4) {&#10;                    const r = parseInt(hex[1] + hex[1], 16);&#10;                    const g = parseInt(hex[2] + hex[2], 16);&#10;                    const b = parseInt(hex[3] + hex[3], 16);&#10;                    return `rgba(${r},${g},${b},${alpha})`;&#10;                }&#10;                return hex;&#10;            }&#10;            // Prepare data for each player (column)&#10;            const datasets = filteredHeaders.map((player, colIdx) =&gt; {&#10;                const color = niceColors[colIdx % niceColors.length];&#10;                const colorTransparent = hexToRgba(color, 0.3);&#10;                return {&#10;                    label: player,&#10;                    data: cumulative[colIdx],&#10;                    fill: false,&#10;                    borderColor: color,&#10;                    tension: 0.1,&#10;                    segment: {&#10;                        borderColor: ctx =&gt; {&#10;                            const i = ctx.p0DataIndex;&#10;                            const data = cumulative[colIdx];&#10;                            if (data[i] === data[i + 1]) {&#10;                                // Use lower alpha for no-change segments&#10;                                return colorTransparent;&#10;                            }&#10;                            return color;&#10;                        }&#10;                    },&#10;                    pointRadius: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        const prev = i &gt; 0 ? data[i-1] : 0;&#10;                        const curr = data[i];&#10;                        const delta = (curr != null &amp;&amp; prev != null) ? curr - prev : null;&#10;                        if (!isFinite(delta) || delta === 0) return 0;&#10;                        return 3;&#10;                    },&#10;                    pointHoverRadius: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        const prev = i &gt; 0 ? data[i-1] : 0;&#10;                        const curr = data[i];&#10;                        const delta = (curr != null &amp;&amp; prev != null) ? curr - prev : null;&#10;                        if (!isFinite(delta) || delta === 0) return 0;&#10;                        return 6;&#10;                    },&#10;                    pointBackgroundColor: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        return isOpaquePoint(data, i) ? color : colorTransparent;&#10;                    },&#10;                    pointBorderColor: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        return isOpaquePoint(data, i) ? color : colorTransparent;&#10;                    }&#10;                };&#10;            });&#10;            // X-axis labels: Use the second column (date/session), formatted as Czech date&#10;            const sessionLabels = rows.map((row, i) =&gt; row[1]);&#10;            // Render chart&#10;            new Chart(document.getElementById('winningsChart').getContext('2d'), {&#10;                type: 'line',&#10;                data: {&#10;                    labels: sessionLabels,&#10;                    datasets: datasets&#10;                },&#10;                options: {&#10;                    responsive: true,&#10;                    maintainAspectRatio: false,&#10;                    interaction: {&#10;                        mode: 'index',&#10;                        intersect: false&#10;                    },&#10;                    plugins: {&#10;                        legend: {&#10;                            display: false&#10;                        },&#10;                        title: {&#10;                            display: true,&#10;                            text: 'Kumulativní šmelo'&#10;                        },&#10;                        tooltip: {&#10;                            enabled: true,&#10;                            bodyFont: {&#10;                                family: 'monospace',&#10;                                size: 14&#10;                            },&#10;                            callbacks: {&#10;                                label: function(context) {&#10;                                    const i = context.dataIndex;&#10;                                    const data = context.dataset.data;&#10;                                    let player = context.dataset.label;&#10;                                    const cumulative = data[i];&#10;                                    const prev = i &gt; 0 ? data[i-1] : 0;&#10;                                    const change = cumulative - prev;&#10;                                    // Always show the hovered dataset, hide others if delta is 0 or not finite&#10;                                    const tooltip = context.chart.tooltip;&#10;                                    const hoveredDatasetIndex = tooltip &amp;&amp; tooltip.dataPoints &amp;&amp; tooltip.dataPoints[0] ? tooltip.dataPoints[0].datasetIndex : null;&#10;                                    if (context.datasetIndex !== hoveredDatasetIndex &amp;&amp; (!isFinite(change) || change === 0)) return '';&#10;                                    // Truncate player name to 8 chars with ... if longer&#10;                                    if (player.match('/')) player = player.split('/')[0];&#10;                                    // Find max player name and total length for alignment&#10;                                    const allLabels = context.chart.data.datasets.map(ds =&gt; {&#10;                                        let l = ds.label;&#10;                                        return l.length &gt; 8 ? 10 : l.length;&#10;                                    });&#10;                                    const namePad = Math.max(...allLabels) ;&#10;                                    // Find max cumulative length for alignment&#10;                                    const allTotals = context.chart.data.datasets.map(ds =&gt; {&#10;                                        const d = ds.data[i];&#10;                                        return d != null ? d.toString().length : 0;&#10;                                    });&#10;                                    const totalPad = Math.max(...allTotals);&#10;                                    const name = player.padEnd(namePad, ' ');&#10;                                    const totalStr = cumulative.toString().padStart(totalPad, ' ');&#10;                                    const sign = change &gt; 0 ? '+' : '';&#10;                                    const deltaStr = sign + change;&#10;                                    return ` ${name}${totalStr} (Δ ${deltaStr})`;&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    scales: {&#10;                        y: {&#10;                            title: {&#10;                                display: true,&#10;                                text: 'Výhra / Ztráta (Kč)'&#10;                            }&#10;                        },&#10;                        x: {&#10;                            title: {&#10;                                display: true,&#10;                                text: 'Datum pošmelení'&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;&lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;title&gt;Poker Winnings Graph&lt;/title&gt;&#10;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/chart.js&quot;&gt;&lt;/script&gt;&#10;    &lt;style&gt;&#10;        html, body {&#10;            height: 100%;&#10;            overflow-y: hidden;&#10;        }&#10;        .chart-scroll-wrapper {&#10;            width: 100%;&#10;            height: 100%;&#10;            overflow-x: auto;&#10;            overflow-y: hidden;&#10;        }&#10;        .chart-scroll-inner {&#10;            min-width: 600px;&#10;            max-width: 1200px;&#10;            margin: 0 auto;&#10;            height: 100%;&#10;            overflow-y: hidden;&#10;            box-sizing: border-box;&#10;            padding-bottom: 16px;&#10;        }&#10;        @media (max-width: 700px) {&#10;            .chart-scroll-inner {&#10;                min-width: 600px;&#10;                width: 100vw;&#10;            }&#10;        }&#10;        @media (max-width: 500px) {&#10;            .chart-scroll-inner {&#10;                min-width: 400px;&#10;                width: 100vw;&#10;            }&#10;        }&#10;        #winningsChart {&#10;            width: 100% !important;&#10;            height: 100% !important;&#10;            display: block;&#10;        }&#10;    &lt;/style&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;div class=&quot;chart-scroll-wrapper&quot;&gt;&#10;  &lt;div class=&quot;chart-scroll-inner&quot;&gt;&#10;    &lt;canvas id=&quot;winningsChart&quot;&gt;&lt;/canvas&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;&#10;&lt;script&gt;&#10;&#10;    const url = `https://docs.google.com/spreadsheets/d/e/2PACX-1vTAYSlBiWTAJ_th0XEzDk9fthNQBrF88_FdBry3l8l9IrcGuopvFoBzIY4Byb5yfTE0U-LyqGkmZxkX/pub?gid=0&amp;single=true&amp;output=csv`;&#10;&#10;    fetch(url)&#10;        .then(response =&gt; response.text()) // Use text() for CSV&#10;        .then(csv =&gt; {&#10;            // Simple CSV parsing (assumes no commas in values)&#10;            const lines = csv.trim().split('\n');&#10;            const headers = lines[0].split(',');&#10;            // Start from line 2 if you have a second header row, else use line 1&#10;            const dataRows = lines.slice(2).map(line =&gt; line.split(','));&#10;            // Filter out rows where the date (second column) is empty&#10;            const rows = dataRows.filter(row =&gt; row[1] &amp;&amp; row[1].trim() !== '');&#10;            // Filter out columns with empty header&#10;            const validColumns = headers.map((h, i) =&gt; ({h, i})).filter(x =&gt; x.h &amp;&amp; x.h.trim() !== '');&#10;            const filteredHeaders = validColumns.map(x =&gt; x.h);&#10;            // Convert all values to numbers (except empty strings)&#10;            const winnings = rows.map(row =&gt; validColumns.map(x =&gt; row[x.i] === '' ? 0 : Number(row[x.i])));&#10;            // Keep original cell values for presence detection (filtered)&#10;            const originalCells = rows.map(row =&gt; validColumns.map(x =&gt; row[x.i]));&#10;            // Compute cumulative sums for each player (column)&#10;            const cumulative = filteredHeaders.map((_, colIdx) =&gt; {&#10;                let sum = 0;&#10;                return winnings.map(row =&gt; sum += (row[colIdx] || 0));&#10;            });&#10;            // After cumulative is built, set values after last session (non-empty, nonzero) for each player to null&#10;            cumulative.forEach((arr, colIdx) =&gt; {&#10;                // Find last index where the original cell is not empty and not zero&#10;                let lastIdx = -1;&#10;                for (let i = arr.length - 1; i &gt;= 0; i--) {&#10;                    const cell = originalCells[i][colIdx];&#10;                    if (cell !== undefined &amp;&amp; cell !== '' &amp;&amp; cell !== '0' &amp;&amp; Number(cell) !== 0) {&#10;                        lastIdx = i;&#10;                        break;&#10;                    }&#10;                }&#10;                if (lastIdx &gt;= 0 &amp;&amp; lastIdx &lt; arr.length - 1) {&#10;                    for (let i = lastIdx + 1; i &lt; arr.length; i++) {&#10;                        arr[i] = null;&#10;                    }&#10;                }&#10;                // Do NOT set points with zero/missing delta to null here, so lines remain continuous&#10;            });&#10;            // Helper to determine if a point should be opaque or alpha&#10;            function isOpaquePoint(data, i) {&#10;                const prev = i &gt; 0 ? data[i] !== data[i-1] : false;&#10;                const next = i &lt; data.length-1 ? data[i] !== data[i+1] : false;&#10;                return prev || next;&#10;            }&#10;            const niceColors = [&#10;                &quot;#E15759&quot;, &quot;#4E79A7&quot;, &quot;#F28E2B&quot;, &quot;#76B7B2&quot;, &quot;#59A14F&quot;, &quot;#EDC948&quot;,&#10;                &quot;#B07AA1&quot;, &quot;#FF9DA7&quot;, &quot;#9C755F&quot;, &quot;#BAB0AC&quot;, &quot;#1F77B4&quot;, &quot;#AEC7E8&quot;,&#10;                &quot;#FF7F0E&quot;, &quot;#FFBB78&quot;, &quot;#2CA02C&quot;, &quot;#98DF8A&quot;, &quot;#D62728&quot;, &quot;#FF9896&quot;,&#10;                &quot;#9467BD&quot;, &quot;#C5B0D5&quot;, &quot;#8C564B&quot;, &quot;#C49C94&quot;, &quot;#E377C2&quot;, &quot;#F7B6D2&quot;,&#10;                &quot;#7F7F7F&quot;, &quot;#C7C7C7&quot;, &quot;#BCBD22&quot;, &quot;#DBDB8D&quot;, &quot;#17BECF&quot;, &quot;#9EDAE5&quot;,&#10;                &quot;#393b79&quot;, &quot;#5254a3&quot;, &quot;#6b6ecf&quot;, &quot;#9c9ede&quot;, &quot;#637939&quot;, &quot;#8ca252&quot;,&#10;                &quot;#b5cf6b&quot;, &quot;#cedb9c&quot;, &quot;#8c6d31&quot;, &quot;#bd9e39&quot;, &quot;#e7ba52&quot;, &quot;#e7cb94&quot;,&#10;                &quot;#843c39&quot;, &quot;#ad494a&quot;, &quot;#d6616b&quot;, &quot;#e7969c&quot;, &quot;#7b4173&quot;, &quot;#a55194&quot;,&#10;                &quot;#ce6dbd&quot;, &quot;#de9ed6&quot;, &quot;#1b9e77&quot;, &quot;#d95f02&quot;&#10;            ];&#10;            // Helper to convert hex to rgba with alpha&#10;            function hexToRgba(hex, alpha) {&#10;                // Accepts #RRGGBB or #RGB&#10;                if (hex.length === 7) {&#10;                    const r = parseInt(hex.slice(1, 3), 16);&#10;                    const g = parseInt(hex.slice(3, 5), 16);&#10;                    const b = parseInt(hex.slice(5, 7), 16);&#10;                    return `rgba(${r},${g},${b},${alpha})`;&#10;                } else if (hex.length === 4) {&#10;                    const r = parseInt(hex[1] + hex[1], 16);&#10;                    const g = parseInt(hex[2] + hex[2], 16);&#10;                    const b = parseInt(hex[3] + hex[3], 16);&#10;                    return `rgba(${r},${g},${b},${alpha})`;&#10;                }&#10;                return hex;&#10;            }&#10;            // Prepare data for each player (column)&#10;            const datasets = filteredHeaders.map((player, colIdx) =&gt; {&#10;                const color = niceColors[colIdx % niceColors.length];&#10;                const colorTransparent = hexToRgba(color, 0.3);&#10;                return {&#10;                    label: player,&#10;                    data: cumulative[colIdx],&#10;                    fill: false,&#10;                    borderColor: color,&#10;                    tension: 0.1,&#10;                    segment: {&#10;                        borderColor: ctx =&gt; {&#10;                            const i = ctx.p0DataIndex;&#10;                            const data = cumulative[colIdx];&#10;                            if (data[i] === data[i + 1]) {&#10;                                // Use lower alpha for no-change segments&#10;                                return colorTransparent;&#10;                            }&#10;                            return color;&#10;                        }&#10;                    },&#10;                    pointRadius: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        const prev = i &gt; 0 ? data[i-1] : 0;&#10;                        const curr = data[i];&#10;                        const delta = (curr != null &amp;&amp; prev != null) ? curr - prev : null;&#10;                        if (!isFinite(delta) || delta === 0) return 0;&#10;                        return 3;&#10;                    },&#10;                    pointHoverRadius: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        const prev = i &gt; 0 ? data[i-1] : 0;&#10;                        const curr = data[i];&#10;                        const delta = (curr != null &amp;&amp; prev != null) ? curr - prev : null;&#10;                        if (!isFinite(delta) || delta === 0) return 0;&#10;                        return 6;&#10;                    },&#10;                    pointBackgroundColor: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        return isOpaquePoint(data, i) ? color : colorTransparent;&#10;                    },&#10;                    pointBorderColor: (ctx) =&gt; {&#10;                        const i = ctx.dataIndex;&#10;                        const data = cumulative[colIdx];&#10;                        return isOpaquePoint(data, i) ? color : colorTransparent;&#10;                    }&#10;                };&#10;            });&#10;            // X-axis labels: Use the second column (date/session), formatted as Czech date&#10;            const sessionLabels = rows.map((row, i) =&gt; row[1]);&#10;            // Render chart&#10;            new Chart(document.getElementById('winningsChart').getContext('2d'), {&#10;                type: 'line',&#10;                data: {&#10;                    labels: sessionLabels,&#10;                    datasets: datasets&#10;                },&#10;                options: {&#10;                    responsive: true,&#10;                    maintainAspectRatio: false,&#10;                    interaction: {&#10;                        mode: 'index',&#10;                        intersect: false&#10;                    },&#10;                    plugins: {&#10;                        legend: {&#10;                            display: false&#10;                        },&#10;                        title: {&#10;                            display: true,&#10;                            text: 'Kumulativní šmelo'&#10;                        },&#10;                        tooltip: {&#10;                            enabled: true,&#10;                            bodyFont: {&#10;                                family: 'monospace',&#10;                                size: 14&#10;                            },&#10;                            callbacks: {&#10;                                label: function(context) {&#10;                                    const i = context.dataIndex;&#10;                                    const data = context.dataset.data;&#10;                                    let player = context.dataset.label;&#10;                                    const cumulative = data[i];&#10;                                    const prev = i &gt; 0 ? data[i-1] : 0;&#10;                                    const change = cumulative - prev;&#10;                                    // Always show the hovered dataset, hide others if delta is 0 or not finite&#10;                                    const tooltip = context.chart.tooltip;&#10;                                    const hoveredDatasetIndex = tooltip &amp;&amp; tooltip.dataPoints &amp;&amp; tooltip.dataPoints[0] ? tooltip.dataPoints[0].datasetIndex : null;&#10;                                    if (context.datasetIndex !== hoveredDatasetIndex &amp;&amp; (!isFinite(change) || change === 0)) return '';&#10;                                    // Truncate player name to 8 chars with ... if longer&#10;                                    if (player.match('/')) player = player.split('/')[0];&#10;                                    // Find max player name and total length for alignment&#10;                                    const allLabels = context.chart.data.datasets.map(ds =&gt; {&#10;                                        let l = ds.label;&#10;                                        return l.length &gt; 8 ? 10 : l.length;&#10;                                    });&#10;                                    const namePad = Math.max(...allLabels) ;&#10;                                    // Find max cumulative length for alignment&#10;                                    const allTotals = context.chart.data.datasets.map(ds =&gt; {&#10;                                        const d = ds.data[i];&#10;                                        return d != null ? d.toString().length : 0;&#10;                                    });&#10;                                    const totalPad = Math.max(...allTotals);&#10;                                    const name = player.padEnd(namePad, ' ');&#10;                                    const totalStr = cumulative.toString().padStart(totalPad, ' ');&#10;                                    const sign = change &gt; 0 ? '+' : '';&#10;                                    const deltaStr = sign + change;&#10;                                    return ` ${name}${totalStr} (Δ ${deltaStr})`;&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    scales: {&#10;                        y: {&#10;                            title: {&#10;                                display: true,&#10;                                text: 'Výhra / Ztráta (Kč)'&#10;                            }&#10;                        },&#10;                        x: {&#10;                            title: {&#10;                                display: true,&#10;                                text: 'Datum pošmelení'&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            });&#10;        });&#10;&lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
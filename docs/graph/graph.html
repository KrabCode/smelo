<!DOCTYPE html>
<html lang="en">
<head>
    <title>Poker Winnings Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        html, body {
            height: 100%;
            overflow-y: hidden;
        }
        .chart-scroll-wrapper {
            width: 100%;
            height: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }
        .chart-scroll-inner {
            min-width: 600px;
            max-width: 1200px;
            margin: 0 auto;
            height: 100%;
            overflow-y: hidden;
            box-sizing: border-box;
            padding-bottom: 16px;
        }
        @media (max-width: 700px) {
            .chart-scroll-inner {
                min-width: 600px;
                width: 100vw;
            }
        }
        @media (max-width: 500px) {
            .chart-scroll-inner {
                min-width: 400px;
                width: 100vw;
            }
        }
        #winningsChart {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
    </style>
</head>
<body>
<div class="chart-scroll-wrapper">
  <div class="chart-scroll-inner">
    <canvas id="winningsChart"></canvas>
  </div>
</div>
<script>

    const url = `https://docs.google.com/spreadsheets/d/e/2PACX-1vTAYSlBiWTAJ_th0XEzDk9fthNQBrF88_FdBry3l8l9IrcGuopvFoBzIY4Byb5yfTE0U-LyqGkmZxkX/pub?gid=0&single=true&output=csv`;

    fetch(url)
        .then(response => response.text()) // Use text() for CSV
        .then(csv => {
            // Simple CSV parsing (assumes no commas in values)
            const lines = csv.trim().split('\n');
            const headers = lines[0].split(',');
            // Start from line 2 if you have a second header row, else use line 1
            const dataRows = lines.slice(2).map(line => line.split(','));
            // Filter out rows where the date (second column) is empty
            const rows = dataRows.filter(row => row[1] && row[1].trim() !== '');
            // Filter out columns with empty header
            const validColumns = headers.map((h, i) => ({h, i})).filter(x => x.h && x.h.trim() !== '');
            const filteredHeaders = validColumns.map(x => x.h);
            // Convert all values to numbers (except empty strings)
            const winnings = rows.map(row => validColumns.map(x => row[x.i] === '' ? 0 : Number(row[x.i])));
            // Keep original cell values for presence detection (filtered)
            const originalCells = rows.map(row => validColumns.map(x => row[x.i]));
            // Compute cumulative sums for each player (column)
            const cumulative = filteredHeaders.map((_, colIdx) => {
                let sum = 0;
                return winnings.map(row => sum += (row[colIdx] || 0));
            });
            // After cumulative is built, set values after last session (non-empty, nonzero) for each player to null
            cumulative.forEach((arr, colIdx) => {
                // Find last index where the original cell is not empty and not zero
                let lastIdx = -1;
                for (let i = arr.length - 1; i >= 0; i--) {
                    const cell = originalCells[i][colIdx];
                    if (cell !== undefined && cell !== '' && cell !== '0' && Number(cell) !== 0) {
                        lastIdx = i;
                        break;
                    }
                }
                if (lastIdx >= 0 && lastIdx < arr.length - 1) {
                    for (let i = lastIdx + 1; i < arr.length; i++) {
                        arr[i] = null;
                    }
                }
                // Do NOT set points with zero/missing delta to null here, so lines remain continuous
            });
            // Helper to determine if a point should be opaque or alpha
            function isOpaquePoint(data, i) {
                const prev = i > 0 ? data[i] !== data[i-1] : false;
                const next = i < data.length-1 ? data[i] !== data[i+1] : false;
                return prev || next;
            }
            const niceColors = [
                "#E15759", "#4E79A7", "#F28E2B", "#76B7B2", "#59A14F", "#EDC948",
                "#B07AA1", "#FF9DA7", "#9C755F", "#BAB0AC", "#1F77B4", "#AEC7E8",
                "#FF7F0E", "#FFBB78", "#2CA02C", "#98DF8A", "#D62728", "#FF9896",
                "#9467BD", "#C5B0D5", "#8C564B", "#C49C94", "#E377C2", "#F7B6D2",
                "#7F7F7F", "#C7C7C7", "#BCBD22", "#DBDB8D", "#17BECF", "#9EDAE5",
                "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252",
                "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94",
                "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194",
                "#ce6dbd", "#de9ed6", "#1b9e77", "#d95f02"
            ];
            // Helper to convert hex to rgba with alpha
            function hexToRgba(hex, alpha) {
                // Accepts #RRGGBB or #RGB
                if (hex.length === 7) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r},${g},${b},${alpha})`;
                } else if (hex.length === 4) {
                    const r = parseInt(hex[1] + hex[1], 16);
                    const g = parseInt(hex[2] + hex[2], 16);
                    const b = parseInt(hex[3] + hex[3], 16);
                    return `rgba(${r},${g},${b},${alpha})`;
                }
                return hex;
            }
            // Prepare data for each player (column)
            const datasets = filteredHeaders.map((player, colIdx) => {
                const color = niceColors[colIdx % niceColors.length];
                const colorTransparent = hexToRgba(color, 0.3);
                return {
                    label: player,
                    data: cumulative[colIdx],
                    fill: false,
                    borderColor: color,
                    tension: 0.1,
                    segment: {
                        borderColor: ctx => {
                            const i = ctx.p0DataIndex;
                            const data = cumulative[colIdx];
                            if (data[i] === data[i + 1]) {
                                // Use lower alpha for no-change segments
                                return colorTransparent;
                            }
                            return color;
                        }
                    },
                    pointRadius: (ctx) => {
                        const i = ctx.dataIndex;
                        const data = cumulative[colIdx];
                        const prev = i > 0 ? data[i-1] : 0;
                        const curr = data[i];
                        const delta = (curr != null && prev != null) ? curr - prev : null;
                        if (!isFinite(delta) || delta === 0) return 0;
                        return 3;
                    },
                    pointHoverRadius: (ctx) => {
                        const i = ctx.dataIndex;
                        const data = cumulative[colIdx];
                        const prev = i > 0 ? data[i-1] : 0;
                        const curr = data[i];
                        const delta = (curr != null && prev != null) ? curr - prev : null;
                        if (!isFinite(delta) || delta === 0) return 0;
                        return 6;
                    },
                    pointBackgroundColor: (ctx) => {
                        const i = ctx.dataIndex;
                        const data = cumulative[colIdx];
                        return isOpaquePoint(data, i) ? color : colorTransparent;
                    },
                    pointBorderColor: (ctx) => {
                        const i = ctx.dataIndex;
                        const data = cumulative[colIdx];
                        return isOpaquePoint(data, i) ? color : colorTransparent;
                    }
                };
            });
            // X-axis labels: Use the second column (date/session), formatted as Czech date
            const sessionLabels = rows.map((row, i) => row[1]);
            // Render chart
            new Chart(document.getElementById('winningsChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: sessionLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Kumulativní šmelo'
                        },
                        tooltip: {
                            enabled: true,
                            bodyFont: {
                                family: 'monospace',
                                size: 14
                            },
                            callbacks: {
                                label: function(context) {
                                    const i = context.dataIndex;
                                    const data = context.dataset.data;
                                    let player = context.dataset.label;
                                    const cumulative = data[i];
                                    const prev = i > 0 ? data[i-1] : 0;
                                    const change = cumulative - prev;
                                    // Always show the hovered dataset, hide others if delta is 0 or not finite
                                    const tooltip = context.chart.tooltip;
                                    const hoveredDatasetIndex = tooltip && tooltip.dataPoints && tooltip.dataPoints[0] ? tooltip.dataPoints[0].datasetIndex : null;
                                    if (context.datasetIndex !== hoveredDatasetIndex && (!isFinite(change) || change === 0)) return '';
                                    // Truncate player name to 8 chars with ... if longer
                                    if (player.match('/')) player = player.split('/')[0];
                                    // Find max player name and total length for alignment
                                    const allLabels = context.chart.data.datasets.map(ds => {
                                        let l = ds.label;
                                        return l.length > 8 ? 10 : l.length;
                                    });
                                    const namePad = Math.max(...allLabels) ;
                                    // Find max cumulative length for alignment
                                    const allTotals = context.chart.data.datasets.map(ds => {
                                        const d = ds.data[i];
                                        return d != null ? d.toString().length : 0;
                                    });
                                    const totalPad = Math.max(...allTotals);
                                    const name = player.padEnd(namePad, ' ');
                                    const totalStr = cumulative.toString().padStart(totalPad, ' ');
                                    const sign = change > 0 ? '+' : '';
                                    const deltaStr = sign + change;
                                    return ` ${name}${totalStr} (Δ ${deltaStr})`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Výhra / Ztráta (Kč)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Datum pošmelení'
                            }
                        }
                    }
                }
            });
        });
</script>
</body>
</html>

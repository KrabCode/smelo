<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shell Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #202020;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #fff;
            border-radius: 8px;
            background-color: #600;
        }
        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #fff;
            color: #8B0000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background-color: #f0f0f0;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        h2 {
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 30px;
            text-align: center;
        }
        #scoreText {
            color: #fff;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }
        #smeloText {
            width: 400px;
            margin: auto;
            text-align: center;
            font-size: 1em;
            font-weight: bold;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 2;
        }
    </style>
</head>
<body>
    <h2>najdi</h2>
    <div id="scoreText" style="margin-bottom: 20px">skóre : 0</div>
    <canvas id="gameCanvas" width="400" height="200" style="display:block;position:relative;z-index:1;"></canvas>
    <button id="shuffleBtn" onclick="shuffleShells()">najdu</button>
    <div id="smeloText">šmelo</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const smeloText = document.getElementById('smeloText');


        // Load images
        const imgShellOpen = new Image();
        imgShellOpen.src = 'shellgame_assets/shell_open.png';
        const imgShellClosed = new Image();
        imgShellClosed.src = 'shellgame_assets/shell_closed.png';
        const imgBall = new Image();
        imgBall.src = 'shellgame_assets/ball.png';

        // Shell positions
        let shells = [
            { x: 80, y: 100, targetX: 80, clicked: false, animProgress: 1, startX: 80, shouldLift: false, flashing: false, hovered: false },
            { x: 200, y: 100, targetX: 200, clicked: false, animProgress: 1, startX: 200, shouldLift: false, flashing: false, hovered: false },
            { x: 320, y: 100, targetX: 320, clicked: false, animProgress: 1, startX: 320, shouldLift: false, flashing: false, hovered: false }
        ];

        let isAnimating = false;
        let gameActive = false; // Track if player can make a selection
        let isFlashing = false; // Track if we're in flash state
        let isPreviewState = true; // Track if we are in preview state
        const shellWidth = 60;
        const shellHeight = 40;

        function drawShells() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Use explicit preview state
            shells.forEach((shell, index) => {
                let yOffset = 0;
                if (shell.shouldLift && shell.animProgress < 1) {
                    const arcProgress = shell.animProgress;
                    const arcHeight = Math.sin(arcProgress * Math.PI) * 30;
                    yOffset = -arcHeight;
                }
                const currentY = shell.y + yOffset;
                let drawOpen = false;
                let drawBall = false;
                // Preview: show open shell with ball in front (overlaid)
                if (isPreviewState && index === 1) {
                    drawOpen = true;
                    drawBall = true;
                } else drawOpen = !!shell.clicked;
                // After preview, all shells closed unless clicked
                const shellImg = drawOpen ? imgShellOpen : imgShellClosed;
                // Draw shell at its natural size, centered
                const shellDrawX = shell.x - shellImg.width / 2;
                const shellDrawY = currentY - shellImg.height / 2;
                ctx.drawImage(shellImg, shellDrawX, shellDrawY);
                // Draw ball only in preview, overlaid in front of open shell
                if (drawBall) {
                    const ballDrawX = shell.x - imgBall.width / 2;
                    const ballDrawY = currentY + shellImg.height / 4 - imgBall.height / 2;
                    ctx.drawImage(imgBall, ballDrawX, ballDrawY);
                }
            });
        }

        function shuffleShells() {
            if (isAnimating) return;
            isPreviewState = false; // End preview as soon as shuffling starts

            // Start flash effect
            isFlashing = true;
            const flashShellIndex = Math.floor(Math.random() * 3);
            shells[flashShellIndex].flashing = true;
            drawShells();
            
            // After flash delay, start the actual shuffling
            setTimeout(() => {
                shells[flashShellIndex].flashing = false;
                isFlashing = false;
                startShuffling();
            }, 300); // Flash for 300ms
        }

        function startShuffling() {
            isAnimating = true;
            shuffleBtn.disabled = true;
            setGameActive(false); // Disable clicking during shuffle
            isPreviewState = false; // Ensure preview is off during shuffling

            // Reset all shell colors and lifted states
            shells.forEach(shell => {
                shell.clicked = false;
                shell.animProgress = 1;
                shell.shouldLift = false;
                shell.flashing = false;
                shell.hovered = false;
            });
            drawShells(); // Ensure all shells are closed before shuffling

            // Random number of shuffles between 30 and 50
            const numberOfShuffles = Math.floor(Math.random() * 10) + 10;
            let currentShuffle = 0;
            
            performNextShuffle();
            
            function performNextShuffle() {
                if (currentShuffle >= numberOfShuffles) {
                    isAnimating = false;
                    shuffleBtn.disabled = true;
                    setGameActive(true); // Enable clicking after shuffle is done, but keep button disabled
                    return;
                }
                
                // Pick two random shells to swap
                const shell1Index = Math.floor(Math.random() * 3);
                let shell2Index = Math.floor(Math.random() * 3);
                
                // Make sure we don't pick the same shell twice
                while (shell2Index === shell1Index) {
                    shell2Index = Math.floor(Math.random() * 3);
                }
                
                // Store current positions
                const shell1CurrentX = shells[shell1Index].x;
                const shell2CurrentX = shells[shell2Index].x;
                
                // Store starting positions for animation
                shells[shell1Index].startX = shells[shell1Index].x;
                shells[shell2Index].startX = shells[shell2Index].x;
                
                // Set target positions (swap them)
                shells[shell1Index].targetX = shell2CurrentX;
                shells[shell2Index].targetX = shell1CurrentX;
                
                // Reset animation progress
                shells[shell1Index].animProgress = 0;
                shells[shell2Index].animProgress = 0;
                
                // Reset all lift states, then mark one of the swapping shells to lift
                shells.forEach(shell => shell.shouldLift = false);
                const liftedShell = Math.random() < 0.5 ? shell1Index : shell2Index;
                shells[liftedShell].shouldLift = true;
                
                currentShuffle++;
                animateShells(() => {
                    // Small delay between shuffles for visual effect
                    setTimeout(performNextShuffle, 30);
                });
            }
        }

        // Easing function (ease-in-out cubic)
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animateShells(onComplete) {
            let allReached = true;
            const animSpeed = 0.08; // Animation speed (0-1 per frame)
            
            shells.forEach(shell => {
                if (shell.animProgress < 1) {
                    shell.animProgress += animSpeed;
                    if (shell.animProgress > 1) shell.animProgress = 1;
                    
                    // Apply easing to the progress
                    const easedProgress = easeInOutCubic(shell.animProgress);
                    
                    // Interpolate position with easing
                    shell.x = shell.startX + (shell.targetX - shell.startX) * easedProgress;
                    
                    if (shell.animProgress < 1) {
                        allReached = false;
                    }
                }
            });
            
            drawShells();
            
            if (!allReached) {
                requestAnimationFrame(() => animateShells(onComplete));
            } else if (onComplete) {
                onComplete();
            }
        }

        // Handle canvas clicks
        canvas.addEventListener('click', function(event) {
            if (isAnimating || !gameActive || isFlashing) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            shells.forEach((shell, index) => {
                let yOffset = 0;
                if (shell.shouldLift && shell.animProgress < 1) {
                    const arcProgress = shell.animProgress;
                    const arcHeight = Math.sin(arcProgress * Math.PI) * 30;
                    yOffset = -arcHeight;
                }
                const currentY = shell.y + yOffset;
                // Use the correct image for hit area
                let drawOpen = false;
                if (isPreviewState && index === 1) {
                    drawOpen = true;
                } else drawOpen = !!shell.clicked;
                const shellImg = drawOpen ? imgShellOpen : imgShellClosed;
                const shellLeft = shell.x - shellImg.width / 2;
                const shellRight = shell.x + shellImg.width / 2;
                const shellTop = currentY - shellImg.height / 2;
                const shellBottom = currentY + shellImg.height / 2;
                if (x >= shellLeft && x <= shellRight && y >= shellTop && y <= shellBottom) {
                    shell.clicked = true;
                    setGameActive(false); // Disable further clicking after first selection
                    shuffleBtn.disabled = false; // Enable shuffle button after shell is chosen
                    showSmeloText(); // Show the "šmelo" text
                    drawShells();
                }
            });
        });

        // Show smelo text after picking a shell
        function showSmeloText() {
            smeloText.style.opacity = '1';
            setTimeout(() => {
                smeloText.style.opacity = '0';
            }, 1000);
        }

        // Handle mouse move for cursor changes
        canvas.addEventListener('mousemove', function(event) {
            if (isAnimating || !gameActive || isFlashing) {
                canvas.style.cursor = 'default';
                shells.forEach(shell => shell.hovered = false);
                drawShells();
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            let overShell = false;
            shells.forEach(shell => shell.hovered = false);
            shells.forEach((shell, index) => {
                let yOffset = 0;
                if (shell.shouldLift && shell.animProgress < 1) {
                    const arcProgress = shell.animProgress;
                    const arcHeight = Math.sin(arcProgress * Math.PI) * 30;
                    yOffset = -arcHeight;
                }
                const currentY = shell.y + yOffset;
                let drawOpen = false;
                if (isPreviewState && index === 1) {
                    drawOpen = true;
                } else drawOpen = !!shell.clicked;
                const shellImg = drawOpen ? imgShellOpen : imgShellClosed;
                const shellLeft = shell.x - shellImg.width / 2;
                const shellRight = shell.x + shellImg.width / 2;
                const shellTop = currentY - shellImg.height / 2;
                const shellBottom = currentY + shellImg.height / 2;
                if (x >= shellLeft && x <= shellRight && y >= shellTop && y <= shellBottom) {
                    overShell = true;
                    shell.hovered = true;
                }
            });
            canvas.style.cursor = overShell ? 'pointer' : 'default';
            drawShells();
        });

        // Initial draw
        function resetPreview() {
            isPreviewState = true;
            shells.forEach(shell => shell.clicked = false);
            drawShells();
            shuffleBtn.disabled = false; // Enable button in preview
        }
        resetPreview();
        shuffleBtn.addEventListener('click', resetPreview);

        // Update shuffle button state when gameActive changes
        function setGameActive(active) {
            gameActive = active;
            shuffleBtn.disabled = active; // Disable button when gameActive is true
        }
    </script>
</body>
</html>
